# 2021Spring  

> 1. CVE-2021-3156  Vulnerability  

>요약

- 일반 로컬 유저가 인증없이 악용할 수 있다.

- 2011년 7월에 언급됬고 sudo 버전 1.8.2 ~ 1.8.31 p2 와 1.9.0 ~ 1.9.5p1의 기본 환경에서 발생한다.

- 우분투 20.04, 데비안 10, 페도라33에서 취약점이 발생하는 것을 확인했고 이와 유사한 운영체제 환경에서도 동작할 것으로 추측된다.


>분석

Sudo가 쉘 모드에서 커맨드를 동작시키기 위해 실행된다면?

커맨드 : (Sudo의 MODE_SHELL 플래그를 설정하는 -s 옵션이나 MODE_SHELL과 MODE_LOGIN_SHELL을 설정하는 -i 옵션)

Sudo의 main()의 도입부에서 parse_args()가 argv 배열을 (모든 커맨드라인 인자를 concatenating 하고 모든 메타캐릭터를 백슬래시를 통해 이스케이프 처리하는 것으로) 덮어 쓴다.

그 후에 sudoers_policy_main()에서 set_cmnd()가 커맨드라인의 인자들을 힙버퍼인 "user_args"에 연결하고 sudoer에 대한 일치 여부와 로깅을 위해 메타캐릭터에 대한 이스케이프 처리를 해제한다.


여기서, 커맨드라인의 인자가 하나의 백슬래시로 끝난다면
from[0]이 백슬래시가 되고 from[1]이 NULL이 됨(인자 배열 종료)

from은 증가하면서 NULL을 가리키게 됨

NULL은 user_args 버퍼로 복사되고 from 배열은 다시 증가하면서 NULL 다음의 첫번쨰 문자를 가리킴

while 루프문이 배열범위 밖의 user_args 버퍼를 읽어와서 복사함


요약하자면, set_cmnd()가 힙 bof를 유발할 수 있다. 왜? 범위 밖의 인자가 user_args로 복사되면서 그 크기에 포함되지 않았기 때문


 이론적으로는, 커맨드라인이 아닌 인자는 백슬래시 캐릭터 하나로 종료됨 : 모드쉘이나 모드로그인 쉘이 설정된다면 모드쉘은 이 설정되고 parse_args()는 이미 모든 메타캐릭터들을 이스케이프한 후임(백슬래시 포함)

 실제로는 취약한 코드 (set_cmnd내부)와  이스케이프 구문 (parse_arg 내부)는 약간 다른 조건들의 영향을 받음. (둘러쌓임?)

 여기서, 모드쉘과 모드에딧 또는 모드체크를 설정할 수 있지만 모드런의 디폴트를 설정할 수는 없는가?
 결론은, 불가능하다. 우리가 모드에딧이나 모드 체크를 설정하면 parse_args()는 모드쉘을 valid_flags에서 삭제하고 에러를 출력하면서 종료한다. 모드쉘과같은 유효하지않은 플래그를 특정화한다면


 근데 허점이 있다. sudo를 sudo대신 sudoedit으로 실행시키면 parse_args는 자동적으로 mode_edit을 설정하지만 valid_flags를 초기화하지 않고 이 valid_flags는 모드쉘에 디폴트로 포함된다.

 따라서, sudoedit-s를 실행하면 modeedit과 modeshell을 설정하고 이스케이프 코드를 우회하고 취약한 코드에 도달하게 된다. 그리고 heap 버퍼인 user_args가 백슬래시로 끝나는 커맨드라인의 인자로인해 오버플로우된다.


 공격자의 관점에서 이 bof는 정말 이상적 조건을 만족한다.

 1. heap 버퍼이자 bof 대상인 userargs의 크기를 제어할 수 있는 점.
 2. 독립적으로 bof 크기와 내용을 조절할 수 있는 점.
 3. null바이트조차 버퍼에 담아 오버플로우 할 수 있는 점.



<!-- 
 예를 들어 amd64 리눅스 환경에서, 다음의 커맨드가 24바이트의 userargs를 할당하고 nextchunksize 필드를 ~~~로 덮어 쓴다면 그것의 forward 필드는 ~가 되고 백워드 필드는 ~가 된다.


>공격

sudo는 main의 도입부에서 지역함수를 호출하기 때문에
그리고 변환 문자열을 포맷스트링 함수로 넘기기 때문에
-->
